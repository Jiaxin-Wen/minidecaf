## 编原step5报告

> 温佳鑫 计84 2017010335

### 1. 实验内容

这个step引入了变量,　所以我索性提前做了初步的名称解析．

python参考实现是多遍的，名称解析要单独遍历一次, 我也按照这样的方法来做

大致思路是:

- 与生成ir的遍历类似，继承Visitor, 重载部分visitXXX函数，在遍历的过程中，记录变量．

- 在这一步中，记录变量最重要的是：记录变量在栈中的地址(即相对于栈帧顶部fp的offset)

  完成这一步后

  - 对变量进行赋值，也就是修改变量所在地址的值(store)
  - 使用变量，也就是使用变量所在地址的值

- "记录"是指：通过名称解析，给AST中的节点增加offset等新属性．

  我只要维护一个node2var的dict, 就可以做到这一点

具体实现上，我依然按照asm生成和ir生成的实现思路．

- 实现一个visitor负责遍历

- 实现一个manager，在visitor的过程中维护名称解析的结果．

### 遇到的问题

1. testcases/step5/missing_return_2.c这个例子让我修复了函数返回值处理的bug. 应该提供默认返回值，然后用一个跳转语句来选择，如果有return语句，就跳过设置默认返回值的语句．

2. 并不是所有expression都需要pop, 只有是statement的expression, 才需要在执行完之后pop. 在g4文件中我们可以通过命名区分这两类，然后在visitXX函数中区别．

### ３. 思考题

##### (1) 描述程序运行过程中函数栈帧的构成，分成哪几个部分？每个部分所用空间最少是多少？

分为三个部分

第一部分是callee保存的寄存器, 比如ra, fp等: 最少空间是8byte

第二部分是局部变量栈, 最少空间是0

第三部分是运算栈，最少空间是0

##### (2) 如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？

定义变量时，原本的逻辑是：如果当前作用域内出现同名变量的声明就报异常，未出现异常就加入node2var的dict．

现在只要取消对同名变量声明的约束即可．因为依然可以通过node找到正确的Variable.

### 3. 代码复用与借鉴

(1) 借鉴了实验指导书中的提示

(2)

- 名称解析阶段：

  借鉴了助教的实现思路，即总体的NameInfo以函数为单位进行管理, 函数管理其作用域内的Variable

  为了debug, 借鉴了助教对`NameInfo.__str__`的实现．

- ir->asm阶段:

  借鉴了助教的实现, 修复了return语句．具体就是指epilogue和return对应的汇编代码的配合．
  
  