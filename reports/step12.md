## 编原step12报告

> 温佳鑫 计84 2017010335

### 1. 实验内容

这一阶段中, 为了将manager和visitor更好的分离(此前我逐渐将越来越多的处理逻辑从visitor挪到manager里, 这是不正确的), 我进行了重构. 之后开始实现对数组的支持

- 名称解析阶段

  引入数组前, size我都使用了默认值. 因此在这一阶段里, 我增加了size的计算, 并完善了变量size的维护.

- 类型检查阶段

  增加数组类型, 补充数组相关的类型检查规则

  补充指针加减法的规则

  左值分析中, 处理数组带来的左值

  > 12.9:
  >
  > 下标运算的结果, 如果类型不是数组, 则是左值

- ir生成

  更新了指针算术的实现

  重载visitPostfixArray函数, 将数组调用翻译成IR

### 2. 思考题

##### (1) 设有以下几个函数，其中局部变量 a 的起始地址都是 0x1000(4096)，请分别给出每个函数的返回值（用一个常量 minidecaf 表达式表示，例如函数 A 的返回值是 *(int*)(4096 + 23 * 4))

```C
 int A() {
     int a[100];
     return a[23];
 }

 int B() {
     int *p = (int*) 4096;
     return p[23];
 }

 int C() {
     int a[10][10];
     return a[2][3];
 }

 int D() {
     int *a[10];
     return a[2][3];
 }

 int E() {
     int **p = (int**) 4096;
     return p[2][3];
 }
```

```
A, B, C : *(int*)(4096 + 23 * 4)
D, E : *(int*)(*(int**)(4096 + 2*4) + 3*4)
```

##### (2) C 语言规范规定，允许局部变量是可变长度的数组（Variable Length Array，VLA），在我们的实验中为了简化，选择不支持它。请你简要回答，如果我们决定支持一维的可变长度的数组(即允许类似 int n = 5; int a[n]; 这种，但仍然不允许类似 int n = ...; int m = ...; int a[n][m]; 这种)，而且要求数组仍然保存在栈上（即不允许用堆上的动态内存申请，如malloc等来实现它），应该在现有的实现基础上做出那些改动？

动态数组的实际大小只能在运行时确定, 如果要求数组仍然保存在站上, 那应该在编译期在栈上预留足够大的空间.

当程序运行到数组声明, 确定实际长度后, 再确定数组的首地址.

### 3. 代码复用与借鉴

借鉴了实验指导书中的提示

