## 编原step11报告

> 温佳鑫 计84 2017010335

### 1. 实验内容

step11主要做了两件事情：

##### 类型检查

在step9实现的框架基础上, 完善类型检查.

##### 左值分析

左值分析的相关规范有以下几条:

>5.5 : 
>
>被声明过的变量是左值 -> visitAtomIdent
>如果e是左值, 那么(e)是左值 -> visitAtomExpr
>
>11.1: 
>
>如果e是类型为T*的表达式，那么*e是类型为T的左值 -> visitCUnary
>可以是一个带有Ident的表达式, 比如a+1
>
>12.9:
>被声明过的变量 && 不是数组 是左值 -> visitAtomIdent加判断

之前我在IRGenVisitor的visitCAssign函数中处理了5.5. 现在将左值分析从IR生成阶段拆分出来, 实现一个LvalueManager(继承DecafVisitor), 在类型检查的过程中顺便做左值分析，并记录左值．到IRGenVisitor中直接使用.

借鉴参考代码的实现, 左值分析的实现思路如下: 

- 在类型检查阶段的遍历过程中, 如果遇到应为左值的地方, 就借助LvalueManger进行左值的检查,

  - 检查成功, 则记录左值信息(就是计算左值地址的ir代码)
  - 检查失败, 则报异常

- LvalueManager以当前节点为根开始搜索,  如果搜索到左值子节点就返回.

参考助教的实现, 将维护左值信息的dict维护成node -> [ir||node]的list

到ir生成阶段, 遍历这个list, 就可以获取左值地址


### 2. 思考题

##### 1.为什么类型检查要放到名称解析之后？

因为类型检查需要名称解析中记录的变量等信息.

##### 2. MiniDecaf 中一个值只能有一种类型，但在很多语言中并非如此，请举出一个反例。

比如c++支持的多重继承, 可以使一个值具有多种类型.

##### 3. 在本次实验中我们禁止进行指针的比大小运算。请问如果要实现指针大小比较需要注意什么问题？可以和原来整数比较的方法一样吗？

和整数比较的方法不完全一样. 因为需要检查指针的类型是否相同.

### 3. 代码复用与借鉴

(1) 借鉴了实验指导书中的提示

(2) 借鉴了助教类型检查框架中对装饰器的合理应用

​	  以及最重要的, 借鉴了助教实现左值分析的思路.

