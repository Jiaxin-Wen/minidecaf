## 编原step9报告

> 温佳鑫 计84 2017010335

### 1. 实验内容

​	此前我们只处理了一个无参函数,且没有调用的基本情况, step9中需要我们对函数做更全面的支持. 包括函数的声明和定义, 函数的调用. 

​	值得一提的实验内容有三点.

##### 1.1

​	在名称解析阶段, 以函数为基本单位, 由函数来管理其作用域内的局部变量. 我维护了一个从函数名称映射到函数名称解析结果的funcDict, 记录函数的名称, 函数作用域内全部局部变量(包括形参)的信息.

##### 1.2

​	这一阶段需要对函数调用时的参数列表做检查. 最初我想在名称解析阶段实现, 但发现由于我在名称解析阶段做了manager和visitor的切分, 导致实现时非常不优雅. 我看到参考实现最后将参数的分析在类型检查阶段实现. 于是我决定先做一个初步的"类型检查"(不检查类型, 只检查函数的参数个数是否匹配), 通过step9,  等到step11再完善.

##### 1.3

​	关于函数调用的实现: 

​	对于一个函数

```c
int func(int a, int b){
    return a + b;
}
```
在名称解析阶段, 我们会通过visitParameterlist将变量a,b记录在func的作用域中, 并确定他们的offset

对于函数调用语句`func(1,2)`,　我们先将参数2, 1压栈, 再call func (注意压栈的顺序, 应该从左向右压栈, 对应名称解析阶段遍历设置offset的顺序).

需要注意的是, 进入到func后，我们本希望通过名称解析阶段确定的offset找到形参，但此时的1,2在func的栈帧上方存储．因此需要将他们的值copy到名称解析阶段确定的offset位置，进而就可以在func中正常使用形参了


### 2. 思考题

1. MiniDecaf 的函数调用时参数求值的顺序是未定义行为。试写出一段 MiniDecaf 代码，使得不同的参数求值顺序会导致不同的返回结果。

   ```c
   int func(int a, int b){
       return a + b;
   }
   int main(){
     int temp = 0;
     func(temp=1, temp);
     return 0;
   }
   ```

### 3. 代码复用与借鉴

(1) 借鉴了实验指导书中的提示

(2) 借鉴了参考实现中, 将类型检查做成单独一个阶段的思路.

